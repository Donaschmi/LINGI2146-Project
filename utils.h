#ifndef UTILS_H_
#define UTILS_H_
#include "contiki.h"
#include <stdlib.h>
#include <stdint.h>

#define CHILDREN_SIZE 10
#define BUFFER_SIZE 30
#define MAX_RETRANSMISSIONS 10
#define MAX_COMPUTATION_PER_SENSOR 5
#define FETCH_DELAY 60
#define TIMEOUT_DELAY 180

static struct broadcast_conn broadcast;
static struct runicast_conn runicast;

enum TYPES {
  DATA,
  COMMAND,
  ALIVE,
  REQUEST,
  UNLINKED
};

/**
 * Open/close valve
 */
enum COMMANDS {
  OPEN,
  CLOSE
};

typedef struct child {
  linkaddr_t addr;
  unsigned long timeout;
} child_t;

typedef struct parent {
  linkaddr_t addr;
  uint8_t id;
  int16_t RSSI;
} parent_t;

/*-----------*/
/**
 * Node specific 
 */
typedef struct node_t {
  linkaddr_t* dest;
  linkaddr_t* reachable_from;
  struct node_t* next;
} node_t;

static node_t* add_to_table(node_t** head, const linkaddr_t* dest, const linkaddr_t* child){
  node_t* node = (node_t*) malloc(sizeof(node_t));
  node->dest = dest;
  node->reachable_from = child;
  node->next = *head;
  (*head) = node;
  return node;
}

static linkaddr_t* get_forward_addr(node_t** head, const linkaddr_t* addr){
  node_t* curr = (*head);
  while (curr != NULL){
    if (linkaddr_cmp(curr->dest, addr)){
      return curr->reachable_from;
    }
    curr = curr->next;
  }
  return NULL;
}

static void remove_from_table(node_t** head, const linkaddr_t* child){
  node_t* curr = (*head);
  node_t* prev = curr;
  node_t* next = NULL;
  while (curr != NULL){
    next = curr->next;
    if (linkaddr_cmp(curr->reachable_from, child)){
      if (curr == (*head)){
        //Removing head
        free(*head);
        (*head) = next;
        curr = next; // really needed?
        prev = next;
      }
      else{
        prev->next = next;
        free(curr);
        curr = next;
      }
    } else{
      prev = curr;
      curr = next;
    }
  }
}

/*----------------------*/
typedef struct packet{
  uint8_t type;
} packet_t;

/**
 * Data generated by sensors and passed to parents
 */
typedef struct data {
  uint8_t type;
  linkaddr_t from;
  double sensor_value;
} data_t;

/**
 * Tell sensor at address dest that it should open the valve (or close it manually)
 */
typedef struct command {
  uint8_t type;
  linkaddr_t dest;
  unsigned open:1;
} command_t;

/**
 * Advertisement
 */
typedef struct alive{
  uint8_t type;
  uint8_t id;
} alive_t;

typedef struct request{
  uint8_t type;
} request_t;

typedef struct unlinked{
  uint8_t type;
} unlinked_t;


typedef struct sensor_values{
  double values[30];
  int index;
  int count;
  linkaddr_t addr;
  unsigned long timeout;
} value_t;

/**
 *  Checks if p is a parent
 *
 *  @param p: Parent node
 *
 *  @return bool: True if p is NOT a parent, else otherwise
 */
static int no_parent(parent_t* p){
  return p->addr.u8[0]==0 && p->addr.u8[1]==0; 
}

/**
 *  Send a runicast request to be child of p_req. If node had a parent before,
 *  removes it
 *
 *  @param p: Current parent node
 *  @param id: id 
 *  @param p_req: new parent address
 */
static void send_request(parent_t* p, uint8_t id, const linkaddr_t* p_req){
  // Reset parent
  p->id = id;
  p->addr.u8[0] = 0;
  p->addr.u8[1] = 0;
  request_t req;
  req.type = REQUEST;
  packetbuf_clear();
  packetbuf_copyfrom(&req, sizeof(request_t));
  runicast_send(&runicast, p_req, MAX_RETRANSMISSIONS);
}

static void send_unlinked(child_t** children){
  unlinked_t unlinked;
  unlinked.type = UNLINKED;
  packetbuf_clear();
  packetbuf_copyfrom(&unlinked, sizeof(unlinked_t));
  broadcast_send(&broadcast);
  printf("Sent unlinked\n");
  int i;
  for(i=0; i< CHILDREN_SIZE; i++)
      children[i] = NULL;
}

static void send_open_valve_command(child_t* child, const linkaddr_t* mote){
  command_t command;
  command.type = COMMAND;
  command.dest.u8[0] = mote->u8[0];
  command.dest.u8[1] = mote->u8[1];
  packetbuf_clear();
  packetbuf_copyfrom(&command, sizeof(command_t));
  runicast_send(&runicast, &child->addr, MAX_RETRANSMISSIONS);
  printf("Sent command to %d\n", mote->u8[0]);
}

static void forward_parent(packet_t* pkt, const linkaddr_t* parent){
  packetbuf_clear();
  packetbuf_copyfrom(pkt, sizeof(data_t));
  runicast_send(&runicast, parent, MAX_RETRANSMISSIONS);
}

/**
 *  Check if mote is a member of children
 *
 *  @param children: the children array
 *  @param mote: the address of the child to check
 *
 *  @return child_t*: the child if it exists, else NULL
 */
static child_t* is_mote_child(child_t** children, const linkaddr_t* mote){
  int i;
  for(i=0; i<CHILDREN_SIZE; i++){
      if (children[i] == NULL)
        continue;
      if (linkaddr_cmp(mote, &children[i]->addr))
          return children[i];
  }
  return NULL;
}

static value_t* is_computing_child(value_t** values, const linkaddr_t* mote){
  int i;
  for(i=0; i < MAX_COMPUTATION_PER_SENSOR; i++){
    if (values[i] ==NULL)
      continue;
    if (linkaddr_cmp(mote, &values[i]->addr))
      return values[i];
  }
  printf("%d : %d\n", values[i]->addr.u8[0], mote->u8[0]);
  return NULL;
}

/**
 * Add a new child to children array
 *
 *  @param children: the children array
 *  @param new_child_addr: Address of the new child to add
 */
static void add_to_children(child_t** children, const linkaddr_t* new_child_addr){
  // Check if this child already exists
  if (is_mote_child(children, new_child_addr) != NULL)
    return;
  child_t* c = (child_t*) malloc(sizeof(child_t));
  if (c == NULL){
    printf("Malloc failed for child.\n"); 
  }
  c->timeout = clock_seconds();
  c->addr.u8[0] = new_child_addr->u8[0];
  c->addr.u8[1] = new_child_addr->u8[1];
  int i;
  for(i=0; i < CHILDREN_SIZE; i++){
    if (children[i] == NULL){ //No child in this slot, can be taken
      children[i] = c;
      printf("added children %d\n", i);
      break;
    }
  }
}

static value_t* add_to_computing(value_t** sensors, const linkaddr_t* from){
  value_t* v = (value_t*) malloc(sizeof(value_t));
  v->index = 0;
  v->count = 0;
  v->timeout = clock_seconds();
  v->addr.u8[0] = from->u8[0];
  v->addr.u8[1] = from->u8[1];
  int i;
  for(i=0; i < MAX_COMPUTATION_PER_SENSOR; i++){
    if (sensors[i] == NULL){
      sensors[i] = v;
      printf("Added at index %d\n", i);
      return v;
    }
  }
  return NULL;
}

static void remove_timedout_children(child_t** children){
  unsigned long time = clock_seconds();
  int i;
  for(i=0; i<CHILDREN_SIZE; i++){
    if (children[i] == NULL)
      continue;
    if (time - children[i]->timeout > TIMEOUT_DELAY) {
      free(children[i]);
      children[i] = NULL;
    }
  }
}

static void remove_timedout_sensors(value_t** sensors){
  unsigned long time = clock_seconds();
  int i;
  for(i=0; i<MAX_COMPUTATION_PER_SENSOR; i++){
    if (sensors[i] == NULL)
      continue;
    if (time - sensors[i]->timeout > TIMEOUT_DELAY) {
      printf("Removed : %d\n", sensors[i]->addr.u8[0]);
      free(sensors[i]);
      sensors[i] = NULL;
    }
  }
}

static void update_child_timeout(child_t** children, const linkaddr_t* from){
  child_t* c = is_mote_child(children, from);
  if (c != NULL){
    c->timeout = clock_seconds();
  }
}

static void update_sensor_data(value_t* value, packet_t* pkt){
  data_t* data = (data_t*) pkt;
  value->values[value->index] = data->sensor_value;
  value->index = (value->index + 1) % 30; // Wrap index
  value->count = value->count == 30 ? 30 : value->count + 1;
  value->timeout = clock_seconds();
}

static int least_squares(value_t* sensor){
  return 1;
}
#endif /* UTILS_H_ */

#define UTILS_H
#include "contiki.h"
#include <stdlib.h>
#include <stdint.h>

#define CHILDREN_SIZE 10
#define BUFFER_SIZE 30
#define MAX_RETRANSMISSIONS 4

static struct broadcast_conn broadcast;
static struct runicast_conn runicast;

enum TYPES {
  DATA,
  COMMAND,
  ALIVE,
  REQUEST,
  UNLINKED
};

/**
 * Open/close valve
 */
enum COMMANDS {
  OPEN,
  CLOSE
};

typedef struct child {
  linkaddr_t addr;
} child_t;

typedef struct parent {
  linkaddr_t addr;
  uint8_t id;
  int16_t RSSI;
} parent_t;


/*----------------------*/
typedef struct packet{
  uint8_t type;
} packet_t;

/**
 * Data generated by sensors and passed to parents
 */
typedef struct data {
  uint8_t type;
  linkaddr_t from;
  int sensor_value;
} data_t;

/**
 * Tell sensor at address dest that it should open the valve (or close it manually)
 */
typedef struct command {
  uint8_t type;
  linkaddr_t dest;
  unsigned open:1;
} command_t;

/**
 * Advertisement
 */
typedef struct alive{
  uint8_t type;
  uint8_t id;
} alive_t;

typedef struct request{
  uint8_t type;
} request_t;

typedef struct unlinked{
  uint8_t type;
} unlinked_t;


typedef struct buffer{
  data_t* data[BUFFER_SIZE];
} buffer_t;

static int no_parent(parent_t* p){
  return p->addr.u8[0]==0 && p->addr.u8[1]==0; 
}

static void send_request(parent_t* p, uint8_t id, const linkaddr_t* p_req){
  // Reset parent
  p->id = id;
  p->addr.u8[0] = 0;
  p->addr.u8[1] = 0;
  request_t req;
  req.type = REQUEST;
  packetbuf_clear();
  packetbuf_copyfrom(&req, sizeof(request_t));
  runicast_send(&runicast, p_req, MAX_RETRANSMISSIONS);
}

static void add_to_children(child_t** children, const linkaddr_t* new_child_addr){
  // Check if this child already exists
  child_t* c = (child_t*) malloc(sizeof(child_t));
  if (c == NULL){
    printf("Malloc failed for child.\n"); 
  }
  c->addr.u8[0] = new_child_addr->u8[0];
  c->addr.u8[1] = new_child_addr->u8[1];
  int i;
  for(i=0; i < CHILDREN_SIZE; i++){
    if (children[i] == NULL){ //No child in this slot, can be taken
      children[i] = c;
      break;
    }
  }
}

static child_t* is_mote_child(child_t** children, const linkaddr_t* mote){
  int i;
  for(i=0; i<CHILDREN_SIZE; i++){
      if (children[i] == NULL)
        continue;
      if (linkaddr_cmp(mote, &children[i]->addr))
          return children[i];
  }
  return NULL;
}

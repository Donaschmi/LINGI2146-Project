#ifndef UTILS_H_
#define UTILS_H_
#include "contiki.h"
#include <stdlib.h>
#include <stdint.h>

#define CHILDREN_SIZE 10
#define BUFFER_SIZE 30
#define MAX_RETRANSMISSIONS 10
#define MAX_COMPUTATION_PER_SENSOR 5
#define FETCH_DELAY 60
#define TIMEOUT_DELAY 180

static struct broadcast_conn broadcast;
static struct runicast_conn runicast;

enum TYPES {
  DATA,
  COMMAND,
  ALIVE,
  REQUEST,
  UNLINKED
};

/**
 * Open/close valve
 */
enum COMMANDS {
  OPEN,
  CLOSE
};

typedef struct child {
  linkaddr_t addr;
  unsigned long timeout;
} child_t;

typedef struct parent {
  linkaddr_t addr;
  uint8_t id;
  int16_t RSSI;
} parent_t;


/*----------------------*/
typedef struct packet{
  uint8_t type;
} packet_t;

/**
 * Data generated by sensors and passed to parents
 */
typedef struct data {
  uint8_t type;
  linkaddr_t from;
  double sensor_value;
} data_t;

/**
 * Tell sensor at address dest that it should open the valve (or close it manually)
 */
typedef struct command {
  uint8_t type;
  linkaddr_t dest;
  unsigned open:1;
} command_t;

/**
 * Advertisement
 */
typedef struct alive{
  uint8_t type;
  uint8_t id;
} alive_t;

typedef struct request{
  uint8_t type;
} request_t;

typedef struct unlinked{
  uint8_t type;
} unlinked_t;


typedef struct sensor_values{
  double values[30];
  int index;
  int count;
  linkaddr_t addr;
} value_t;

/**
 *  Checks if p is a parent
 *
 *  @param p: Parent node
 *
 *  @return bool: True if p is NOT a parent, else otherwise
 */
static int no_parent(parent_t* p){
  return p->addr.u8[0]==0 && p->addr.u8[1]==0; 
}

/**
 *  Send a runicast request to be child of p_req. If node had a parent before,
 *  removes it
 *
 *  @param p: Current parent node
 *  @param id: id 
 *  @param p_req: new parent address
 */
static void send_request(parent_t* p, uint8_t id, const linkaddr_t* p_req){
  // Reset parent
  p->id = id;
  p->addr.u8[0] = 0;
  p->addr.u8[1] = 0;
  request_t req;
  req.type = REQUEST;
  packetbuf_clear();
  packetbuf_copyfrom(&req, sizeof(request_t));
  runicast_send(&runicast, p_req, MAX_RETRANSMISSIONS);
}

static void send_unlinked(child_t** children){
  unlinked_t unlinked;
  unlinked.type = UNLINKED;
  packetbuf_copyfrom(&unlinked, sizeof(unlinked_t));
  broadcast_send(&broadcast);
  printf("Sent unlinked\n");
  int i;
for(i=0; i< CHILDREN_SIZE; i++)
    children[i] = NULL;
}

static void forward_parent(packet_t* pkt, const linkaddr_t* parent){
  packetbuf_copyfrom(pkt, sizeof(data_t));
  runicast_send(&runicast, parent, MAX_RETRANSMISSIONS);
}

/**
 *  Check if mote is a member of children
 *
 *  @param children: the children array
 *  @param mote: the address of the child to check
 *
 *  @return child_t*: the child if it exists, else NULL
 */
static child_t* is_mote_child(child_t** children, const linkaddr_t* mote){
  int i;
  for(i=0; i<CHILDREN_SIZE; i++){
      if (children[i] == NULL)
        continue;
      if (linkaddr_cmp(mote, &children[i]->addr))
          return children[i];
  }
  return NULL;
}

static value_t* is_computing_child(value_t** values, const linkaddr_t* mote){
  int i;
  for(i=0; i < MAX_COMPUTATION_PER_SENSOR; i++){
    if (values[i] ==NULL)
      continue;
    if (linkaddr_cmp(mote, &values[i]->addr))
      return values[i];
  }
  return NULL;
}

/**
 * Add a new child to children array
 *
 *  @param children: the children array
 *  @param new_child_addr: Address of the new child to add
 */
static void add_to_children(child_t** children, const linkaddr_t* new_child_addr){
  // Check if this child already exists
  if (is_mote_child(children, new_child_addr) != NULL)
    return;
  child_t* c = (child_t*) malloc(sizeof(child_t));
  if (c == NULL){
    printf("Malloc failed for child.\n"); 
  }
  c->timeout = clock_seconds();
  c->addr.u8[0] = new_child_addr->u8[0];
  c->addr.u8[1] = new_child_addr->u8[1];
  int i;
  for(i=0; i < CHILDREN_SIZE; i++){
    if (children[i] == NULL){ //No child in this slot, can be taken
      children[i] = c;
      printf("added children %d\n", i);
      break;
    }
  }
}

static value_t* add_to_computing(value_t** sensors, linkaddr_t* from){
  value_t* v = (value_t*) malloc(sizeof(value_t));
  v->index = 0;
  v->count = 0;
  v->addr.u8[0] = from->u8[0];
  v->addr.u8[1] = from->u8[1];
  int i;
  for(i=0; i < MAX_COMPUTATION_PER_SENSOR; i++){
    if (sensors[i] == NULL){
      sensors[i] = v;
      return v;
    }
  }
  return NULL;
}

static void remove_timedout_children(child_t** children){
  unsigned long time = clock_seconds();
  int i;
  for(i=0; i<CHILDREN_SIZE; i++){
    if (children[i] == NULL)
      continue;
    if (time - children[i]->timeout > TIMEOUT_DELAY) {
      printf("timeout : %li : %li\n", children[i]->timeout, clock_seconds());
      printf("Removed : %d\n", children[i]->addr.u8[0]);
      free(children[i]);
      children[i] = NULL;
    }
  }
}

static void update_child_timeout(child_t** children, const linkaddr_t* from){
  child_t* c = is_mote_child(children, from);
  if (c != NULL){
    c->timeout = clock_seconds();
  }
}

static void update_sensor_data(value_t* value, packet_t* pkt){
  data_t* data = (data_t*) pkt;
  value->values[value->index] = data->sensor_value;
  value->index = (value->index + 1) % 30; // Wrap index
  value->count = value->count == 30 ? 30 : value->count + 1;
}
#endif /* UTILS_H_ */
